# -*- coding: utf-8 -*-
"""Zadatak2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lsM-1vHSGRyrDtYHxPCp_VPw-tLfDQiY
"""

import numpy as np
import matplotlib.pyplot as plt

# PARAMETRI PLOČE

L = 1.0
dx = 0.1
dy = 0.1

nx = int(L/dx) + 1
ny = int(L/dy) + 1

q = 100.0
D = 1.0

eps = 0.001
max_iter = 10000


# GAUSS–SEIDEL (TAČKA)

def gauss_seidel_poisson(rhs, omega=1.0):

    phi = np.zeros((nx, ny))
    iteration = 0

    while iteration < max_iter:

        phi_old = phi.copy()

        for i in range(1, nx-1):
            for j in range(1, ny-1):

                phi[i, j] = (1-omega)*phi[i, j] + omega*0.25*(
                    phi[i+1, j] + phi[i-1, j] +
                    phi[i, j+1] + phi[i, j-1]
                    - dx**2 * rhs[i, j]
                )

        # Dirichlet granice
        phi[0, :] = 0
        phi[-1, :] = 0
        phi[:, 0] = 0
        phi[:, -1] = 0

        error = np.max(np.abs(phi - phi_old))

        if error < eps:
            break

        iteration += 1

    return phi, iteration


# JAKOBI

def jacobi_poisson(rhs):

    phi = np.zeros((nx, ny))
    iteration = 0

    while iteration < max_iter:

        phi_old = phi.copy()

        for i in range(1, nx-1):
            for j in range(1, ny-1):

                phi[i, j] = 0.25*(
                    phi_old[i+1, j] + phi_old[i-1, j] +
                    phi_old[i, j+1] + phi_old[i, j-1]
                    - dx**2 * rhs[i, j]
                )

        phi[0, :] = 0
        phi[-1, :] = 0
        phi[:, 0] = 0
        phi[:, -1] = 0

        error = np.max(np.abs(phi - phi_old))

        if error < eps:
            break

        iteration += 1

    return phi, iteration


# GS LINIJSKI

def gs_line_poisson(rhs, omega=1.0):

    phi = np.zeros((nx, ny))
    iteration = 0

    while iteration < max_iter:

        phi_old = phi.copy()

        for i in range(1, nx-1):
            for j in range(1, ny-1):

                phi[i, j] = (1-omega)*phi[i, j] + omega*0.25*(
                    phi[i+1, j] + phi[i-1, j] +
                    phi[i, j+1] + phi[i, j-1]
                    - dx**2 * rhs[i, j]
                )

        phi[0, :] = 0
        phi[-1, :] = 0
        phi[:, 0] = 0
        phi[:, -1] = 0

        error = np.max(np.abs(phi - phi_old))

        if error < eps:
            break

        iteration += 1

    return phi, iteration


# ADI

def adi_poisson(rhs):

    phi = np.zeros((nx, ny))
    iteration = 0

    while iteration < max_iter:

        phi_old = phi.copy()

        # sweep x
        for i in range(1, nx-1):
            for j in range(1, ny-1):
                phi[i, j] = 0.25*(
                    phi[i+1, j] + phi[i-1, j] +
                    phi[i, j+1] + phi[i, j-1]
                    - dx**2 * rhs[i, j]
                )

        # sweep y
        for j in range(1, ny-1):
            for i in range(1, nx-1):
                phi[i, j] = 0.25*(
                    phi[i+1, j] + phi[i-1, j] +
                    phi[i, j+1] + phi[i, j-1]
                    - dx**2 * rhs[i, j]
                )

        phi[0, :] = 0
        phi[-1, :] = 0
        phi[:, 0] = 0
        phi[:, -1] = 0

        error = np.max(np.abs(phi - phi_old))

        if error < eps:
            break

        iteration += 1

    return phi, iteration


# ANALIZA OMEGA

rhs_u = np.full((nx, ny), q/D)

omegas = np.linspace(1.0, 1.9, 10)
iterations_omega = []

for omega in omegas:
    _, it_temp = gauss_seidel_poisson(rhs_u, omega=omega)
    iterations_omega.append(it_temp)

plt.figure()
plt.plot(omegas, iterations_omega, marker='o')
plt.xlabel("Omega")
plt.ylabel("Broj iteracija")
plt.title("Zavisnost iteracija od omega")
plt.grid()
plt.show()

optimal_omega = omegas[np.argmin(iterations_omega)]
print("Optimalni omega:", optimal_omega)


# REŠENJA

u_gs, it_u = gauss_seidel_poisson(rhs_u, omega=optimal_omega)
w_gs, it_w = gauss_seidel_poisson(u_gs, omega=optimal_omega)

print(f"GS tačka: u = {it_u}, w = {it_w}")

u_jac, it_jac_u = jacobi_poisson(rhs_u)
w_jac, it_jac_w = jacobi_poisson(u_jac)

print(f"Jakobi: u = {it_jac_u}, w = {it_jac_w}")

u_line, it_line_u = gs_line_poisson(rhs_u, omega=optimal_omega)
w_line, it_line_w = gs_line_poisson(u_line, omega=optimal_omega)

print(f"GS linijski: u = {it_line_u}, w = {it_line_w}")

u_adi, it_adi_u = adi_poisson(rhs_u)
w_adi, it_adi_w = adi_poisson(u_adi)

print(f"ADI: u = {it_adi_u}, w = {it_adi_w}")


# KONTOURE UGIBA

x = np.linspace(0, L, nx)
y = np.linspace(0, L, ny)
X, Y = np.meshgrid(x, y)

plt.figure()
plt.contourf(X, Y, w_gs.T, 20)
plt.colorbar(label="Ugib w")
plt.title("Raspodela ugiba ploče")
plt.xlabel("x")
plt.ylabel("y")
plt.show()

